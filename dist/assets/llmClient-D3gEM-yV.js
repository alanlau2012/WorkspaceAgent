class i{constructor(){this.providers=new Map,this.initializeProviders()}initializeProviders(){this.providers.set("mock-echo",{name:"Mock Echo",sendMessage:async({messages:e})=>{await new Promise(r=>setTimeout(r,500+Math.random()*1e3));const s=e[e.length-1];return{content:`回声: ${s.content}`,model:"mock-echo",usage:{tokens:s.content.length}}}}),this.providers.set("mock-assistant",{name:"Mock Assistant",sendMessage:async({messages:e,context:s})=>{await new Promise(o=>setTimeout(o,800+Math.random()*1200));const r=e[e.length-1],n=r.content.toLowerCase();let t="";if(n.includes("你好")||n.includes("hello"))t="你好！我是 WorkspaceAgent 的 AI 助手。我可以帮助你管理文件、回答问题。有什么我可以帮助你的吗？";else if(n.includes("文件")||n.includes("file"))s&&s.files?t=`我看到你当前选择了 ${s.files.length} 个文件。我可以帮你分析这些文件的内容，或者协助进行文件操作。`:t="我可以帮助你进行文件管理操作，比如创建、删除、重命名文件等。你可以先在左侧选择一些文件，然后我就能基于这些文件为你提供更具体的帮助。";else if(n.includes("谢谢")||n.includes("thank"))t="不客气！如果还有其他问题，随时可以问我。";else if(n.includes("帮助")||n.includes("help"))t=`我可以为你提供以下帮助：
• 文件管理：创建、删除、重命名文件
• 代码分析：解释代码逻辑、发现问题
• 内容总结：总结文档内容
• 问题解答：回答技术问题

请告诉我你需要什么帮助！`;else{const o=["这是一个很有趣的问题。让我想想...","我理解你的意思。基于当前的上下文，我建议...","这个问题涉及多个方面。让我为你详细分析一下。","好问题！这让我想到了几个相关的要点。"];t=`${o[Math.floor(Math.random()*o.length)]}

对于"${r.content}"这个问题，我需要更多信息才能给出准确的回答。你能提供更多细节吗？`}return{content:t,model:"mock-assistant",usage:{tokens:t.length}}}}),this.providers.set("gpt-3.5-turbo",{name:"GPT-3.5 Turbo",sendMessage:async()=>{throw new Error("OpenAI API 尚未配置。请在设置中添加 API 密钥。")}}),this.providers.set("gpt-4",{name:"GPT-4",sendMessage:async()=>{throw new Error("OpenAI API 尚未配置。请在设置中添加 API 密钥。")}})}async sendMessage({model:e,messages:s,context:r,config:n}){const t=this.providers.get(e);if(!t)throw new Error(`未知的模型: ${e}`);try{return await t.sendMessage({messages:s,context:r,config:n})}catch(o){throw new Error(`${t.name} 错误: ${o.message}`)}}getAvailableModels(){return Array.from(this.providers.keys()).map(e=>({id:e,name:this.providers.get(e).name}))}isModelAvailable(e){return this.providers.has(e)}registerModel(e,s){if(!e||typeof e!="string")throw new Error("模型ID必须是非空字符串");if(!s||typeof s.sendMessage!="function")throw new Error("提供者必须包含 sendMessage 方法");this.providers.set(e,s)}unregisterModel(e){this.providers.delete(e)}hasModel(e){return this.providers.has(e)}updateModel(e,s){this.registerModel(e,s)}}const d=new i;export{i as LLMClient,d as llmClient};
